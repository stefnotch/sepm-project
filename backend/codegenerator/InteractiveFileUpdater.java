package at.ac.tuwien.sepm.groupphase.backend.codegenerator;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import java.util.Arrays;
import java.util.HashSet;
import java.util.HexFormat;
import java.util.Locale;
import java.util.Scanner;
import java.util.Set;
import java.util.stream.Stream;

/**
 * Updates autogenerated files, and asks the user if anything unexpected happens.
 *
 * <p>It first searches for old files, then updates them one by one,
 * and finally cleans up the remaining ones.
 */
public class InteractiveFileUpdater {
    private static final String FILE_HEADER_START = "/** File Hash: ";
    private static final String FILE_HEADER_END = " */\n";
    private final MessageDigest digest;
    private final Scanner scanner;

    private final Set<Path> filesToUpdate = new HashSet<>();
    private final Path directoryPath;
    private final String fileExtension;

    /**
     * Creates a new {@link InteractiveFileUpdater}.
     *
     * @param directoryPath the directory where the files to update are.
     * @param fileExtension the file extension that all autogenerated files must have.
     */
    public InteractiveFileUpdater(Path directoryPath, String fileExtension) {
        this.directoryPath = directoryPath;
        this.fileExtension = fileExtension;
        try {
            digest = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
        scanner = new Scanner(System.in);
    }

    /**
     * Searches for all old autogenerated files and notes them down.
     *
     * @throws IOException if an IO error happened while accessing one of the old files.
     */
    public void findFilesToUpdate() throws IOException {
        filesToUpdate.clear();

        try (Stream<Path> recursiveWalker = Files.walk(directoryPath)) {
            filesToUpdate.addAll(
                recursiveWalker
                    .filter(Files::isRegularFile)
                    .filter(this::hasExpectedExtension)
                    .filter(v -> {
                        try (Stream<String> lines = Files.lines(v)) {
                            return lines
                                .findFirst()
                                .orElse("")
                                .startsWith(FILE_HEADER_START);
                        } catch (IOException e) {
                            System.err.println(e);
                            return false;
                        }
                    })
                    .map(Path::normalize)
                    .toList()
            );
        }
    }

    /**
     * Updates one autogenerated file.
     * Will create a new file if it doesn't exist, otherwise it'll check the old file and update it.
     *
     * <p>If the old file is not an autogenerated file or has been modified, this method will ask the user.
     *
     * @param fileToUpdate the path of the file.
     * @param contents     the new contents of the file.
     * @throws IOException if an IO error happened while accessing the files.
     */
    public void interactiveUpdateFile(Path fileToUpdate, String contents) throws IOException {
        var filePath = fileToUpdate.normalize();
        if (!filePath.startsWith(directoryPath)) {
            throw new IllegalArgumentException("Filepath is not in expected directory " + filePath);
        }
        if (!hasExpectedExtension(filePath)) {
            throw new IllegalArgumentException("Filepath does not have the expected file extension " + filePath);
        }

        // Not ideal file handling in multithreaded environments
        if (!Files.exists(filePath)) {
            // Safe to just update the file
            writeFile(filePath, contents);
            return;
        }

        var hexConverter = HexFormat.of();

        String logHeader = "\n[" + filePath + "]";

        String oldContents = Files.readString(filePath);
        if (!oldContents.startsWith(FILE_HEADER_START)) {
            logMessage(logHeader);
            logMessage("Expected to find a file starting with " + FILE_HEADER_START);
            boolean overwriteFile = askUser("Should the file be overwritten?");
            if (overwriteFile) {
                writeFile(filePath, contents);
            }
            return;
        }

        int hashStartIndex = oldContents.indexOf(FILE_HEADER_START) + FILE_HEADER_START.length();
        int hashEndIndex = oldContents.indexOf(FILE_HEADER_END, hashStartIndex);
        if (hashEndIndex == -1) {
            logMessage(logHeader);
            logMessage("Expected to find a file with a valid header that ends with " + FILE_HEADER_END.trim());
            boolean overwriteFile = askUser("Should the file be overwritten?");
            if (overwriteFile) {
                writeFile(filePath, contents);
            }
            return;
        }

        var hash = hexConverter.parseHex(oldContents.substring(hashStartIndex, hashEndIndex));
        String restOfFile = oldContents.substring(hashEndIndex + FILE_HEADER_END.length());

        var fileHash = getHash(stripSpaces(restOfFile));
        if (!Arrays.equals(hash, fileHash)) {
            logMessage(logHeader);
            logMessage("The file has been manually modified, the header hash is "
                + hexConverter.formatHex(hash)
                + " but the file contents have a hash of "
                + hexConverter.formatHex(fileHash)
            );
            boolean overwriteFile = askUser("Should the file be overwritten?");
            if (overwriteFile) {
                writeFile(filePath, contents);
            }
            return;
        }

        // Safe to just update the file
        writeFile(filePath, contents);
    }

    /**
     * Deletes autogenerated files that have not been updated.
     *
     * @throws IOException if an IO error happened while deleting one of the files.
     */
    public void cleanupRemainingFiles() throws IOException {
        if (filesToUpdate.isEmpty()) {
            return;
        }

        logMessage("Other autogenerated files have been found: ");
        filesToUpdate.forEach(v -> logMessage("  " + v.toString()));
        logMessage("");
        boolean deleteFiles = askUser("Should these files be removed?");
        if (deleteFiles) {
            for (Path path : filesToUpdate) {
                Files.delete(path);
            }
        }
    }

    private boolean askUser(String question) {
        logMessage(question + "(y/n)");
        while (true) {
            String userInput = scanner.nextLine();
            if (userInput.toLowerCase(Locale.ROOT)
                .startsWith("y")) {
                return true;
            } else if (userInput.toLowerCase(Locale.ROOT)
                .startsWith("n")) {
                return false;
            }
        }
    }

    private void logMessage(String message) {
        System.out.println(message);
    }

    /**
     * Writes a file, and includes a hash so that modifications can be detected.
     */
    private void writeFile(Path filePath, String contents) throws IOException {
        filesToUpdate.remove(filePath);
        var hexConverter = HexFormat.of();
        var hash = getHash(contents);
        String header = FILE_HEADER_START + hexConverter.formatHex(hash) + FILE_HEADER_END;
        Files.createDirectories(filePath.getParent());
        Files.writeString(filePath, header + "\n" + contents);
    }

    private byte[] getHash(String contents) {
        // Strips the spaces so that minor differences in whitespaces are ignored
        return digest.digest(stripSpaces(contents).getBytes(StandardCharsets.UTF_8));
    }

    private String stripSpaces(String contents) {
        // A tokenizer that keeps spaces inside Typescript strings would be even cooler
        return contents.replaceAll("\\s", "");
    }

    private boolean hasExpectedExtension(Path filePath) {
        return filePath.toString()
            .toLowerCase(Locale.ROOT)
            .endsWith(fileExtension);
    }
}
